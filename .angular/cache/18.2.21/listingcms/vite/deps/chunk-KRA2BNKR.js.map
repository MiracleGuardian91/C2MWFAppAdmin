{
  "version": 3,
  "sources": ["../../../../../../node_modules/bpmn-js/lib/util/LabelUtil.js"],
  "sourcesContent": ["import { assign } from 'min-dash';\nimport { is } from './ModelUtil';\nimport { isLabel } from 'diagram-js/lib/util/ModelUtil';\nexport { isLabel } from 'diagram-js/lib/util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n * @typedef {import('diagram-js/lib/util/Types').Rect} Rect\n *\n * @typedef {import('../model/Types').Element} Element\n * @typedef {import('../model/Types').ModdleElement} ModdleElement\n */\n\nexport var DEFAULT_LABEL_SIZE = {\n  width: 90,\n  height: 20\n};\nexport var FLOW_LABEL_INDENT = 15;\n\n/**\n * Return true if the given semantic has an external label.\n *\n * @param {Element} semantic\n *\n * @return {boolean}\n */\nexport function isLabelExternal(semantic) {\n  return is(semantic, 'bpmn:Event') || is(semantic, 'bpmn:Gateway') || is(semantic, 'bpmn:DataStoreReference') || is(semantic, 'bpmn:DataObjectReference') || is(semantic, 'bpmn:DataInput') || is(semantic, 'bpmn:DataOutput') || is(semantic, 'bpmn:SequenceFlow') || is(semantic, 'bpmn:MessageFlow') || is(semantic, 'bpmn:Group');\n}\n\n/**\n * Return true if the given element has an external label.\n *\n * @param {Element} element\n *\n * @return {boolean}\n */\nexport function hasExternalLabel(element) {\n  return isLabel(element.label);\n}\n\n/**\n * Get the position of a sequence flow label.\n *\n * @param  {Point[]} waypoints\n *\n * @return {Point}\n */\nexport function getFlowLabelPosition(waypoints) {\n  // get the waypoints mid\n  var mid = waypoints.length / 2 - 1;\n  var first = waypoints[Math.floor(mid)];\n  var second = waypoints[Math.ceil(mid + 0.01)];\n\n  // get position\n  var position = getWaypointsMid(waypoints);\n\n  // calculate angle\n  var angle = Math.atan((second.y - first.y) / (second.x - first.x));\n  var x = position.x,\n    y = position.y;\n  if (Math.abs(angle) < Math.PI / 2) {\n    y -= FLOW_LABEL_INDENT;\n  } else {\n    x += FLOW_LABEL_INDENT;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n\n/**\n * Get the middle of a number of waypoints.\n *\n * @param  {Point[]} waypoints\n *\n * @return {Point}\n */\nexport function getWaypointsMid(waypoints) {\n  var mid = waypoints.length / 2 - 1;\n  var first = waypoints[Math.floor(mid)];\n  var second = waypoints[Math.ceil(mid + 0.01)];\n  return {\n    x: first.x + (second.x - first.x) / 2,\n    y: first.y + (second.y - first.y) / 2\n  };\n}\n\n/**\n * Get the middle of the external label of an element.\n *\n * @param {Element} element\n *\n * @return {Point}\n */\nexport function getExternalLabelMid(element) {\n  if (element.waypoints) {\n    return getFlowLabelPosition(element.waypoints);\n  } else if (is(element, 'bpmn:Group')) {\n    return {\n      x: element.x + element.width / 2,\n      y: element.y + DEFAULT_LABEL_SIZE.height / 2\n    };\n  } else {\n    return {\n      x: element.x + element.width / 2,\n      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2\n    };\n  }\n}\n\n/**\n * Return the bounds of an elements label, parsed from the elements DI or\n * generated from its bounds.\n *\n * @param {ModdleElement} di\n * @param {Element} element\n *\n * @return {Rect}\n */\nexport function getExternalLabelBounds(di, element) {\n  var mid,\n    size,\n    bounds,\n    label = di.label;\n  if (label && label.bounds) {\n    bounds = label.bounds;\n    size = {\n      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),\n      height: bounds.height\n    };\n    mid = {\n      x: bounds.x + bounds.width / 2,\n      y: bounds.y + bounds.height / 2\n    };\n  } else {\n    mid = getExternalLabelMid(element);\n    size = DEFAULT_LABEL_SIZE;\n  }\n  return assign({\n    x: mid.x - size.width / 2,\n    y: mid.y - size.height / 2\n  }, size);\n}\n\n/**\n * @param {ModdleElement} semantic\n *\n * @returns {string}\n */\nfunction getLabelAttr(semantic) {\n  if (is(semantic, 'bpmn:FlowElement') || is(semantic, 'bpmn:Participant') || is(semantic, 'bpmn:Lane') || is(semantic, 'bpmn:SequenceFlow') || is(semantic, 'bpmn:MessageFlow') || is(semantic, 'bpmn:DataInput') || is(semantic, 'bpmn:DataOutput')) {\n    return 'name';\n  }\n  if (is(semantic, 'bpmn:TextAnnotation')) {\n    return 'text';\n  }\n  if (is(semantic, 'bpmn:Group')) {\n    return 'categoryValueRef';\n  }\n}\n\n/**\n * @param {ModdleElement} semantic\n *\n * @returns {string}\n */\nfunction getCategoryValue(semantic) {\n  var categoryValueRef = semantic['categoryValueRef'];\n  if (!categoryValueRef) {\n    return '';\n  }\n  return categoryValueRef.value || '';\n}\n\n/**\n * @param {Element} element\n *\n * @return {string}\n */\nexport function getLabel(element) {\n  var semantic = element.businessObject,\n    attr = getLabelAttr(semantic);\n  if (attr) {\n    if (attr === 'categoryValueRef') {\n      return getCategoryValue(semantic);\n    }\n    return semantic[attr] || '';\n  }\n}\n\n/**\n * @param {Element} element\n * @param {string} text\n *\n * @return {Element}\n */\nexport function setLabel(element, text) {\n  var semantic = element.businessObject,\n    attr = getLabelAttr(semantic);\n  if (attr) {\n    if (attr === 'categoryValueRef') {\n      if (!semantic[attr]) {\n        return element;\n      }\n      semantic[attr].value = text;\n    } else {\n      semantic[attr] = text;\n    }\n  }\n  return element;\n}"],
  "mappings": "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",
  "names": []
}
