{
  "version": 3,
  "sources": ["../../../../../../node_modules/diagram-js/lib/features/rules/RuleProvider.js"],
  "sourcesContent": ["import inherits from 'inherits-browser';\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * @typedef {import('../../core/EventBus').default} EventBus\n */\n\n/**\n * A basic provider that may be extended to implement modeling rules.\n *\n * Extensions should implement the init method to actually add their custom\n * modeling checks. Checks may be added via the #addRule(action, fn) method.\n *\n * @class\n *\n * @param {EventBus} eventBus\n */\nexport default function RuleProvider(eventBus) {\n  CommandInterceptor.call(this, eventBus);\n  this.init();\n}\nRuleProvider.$inject = ['eventBus'];\ninherits(RuleProvider, CommandInterceptor);\n\n/**\n * Adds a modeling rule for the given action, implemented through\n * a callback function.\n *\n * The callback receives a modeling specific action context\n * to perform its check. It must return `false` to disallow the\n * action from happening or `true` to allow the action. Usually returing\n * `null` denotes that a particular interaction shall be ignored.\n * By returning nothing or `undefined` you pass evaluation to lower\n * priority rules.\n *\n * @example\n *\n * ```javascript\n * ResizableRules.prototype.init = function() {\n *\n *   \\/**\n *    * Return `true`, `false` or nothing to denote\n *    * _allowed_, _not allowed_ and _continue evaluating_.\n *    *\\/\n *   this.addRule('shape.resize', function(context) {\n *\n *     var shape = context.shape;\n *\n *     if (!context.newBounds) {\n *       // check general resizability\n *       if (!shape.resizable) {\n *         return false;\n *       }\n *\n *       // not returning anything (read: undefined)\n *       // will continue the evaluation of other rules\n *       // (with lower priority)\n *       return;\n *     } else {\n *       // element must have minimum size of 10*10 points\n *       return context.newBounds.width > 10 && context.newBounds.height > 10;\n *     }\n *   });\n * };\n * ```\n *\n * @param {string|string[]} actions the identifier for the modeling action to check\n * @param {number} [priority] the priority at which this rule is being applied\n * @param {(any) => any} fn the callback function that performs the actual check\n */\nRuleProvider.prototype.addRule = function (actions, priority, fn) {\n  var self = this;\n  if (typeof actions === 'string') {\n    actions = [actions];\n  }\n  actions.forEach(function (action) {\n    self.canExecute(action, priority, function (context, action, event) {\n      return fn(context);\n    }, true);\n  });\n};\n\n/**\n * Implement this method to add new rules during provider initialization.\n */\nRuleProvider.prototype.init = function () {};"],
  "mappings": ";;;;;;;;AAiBe,SAAR,aAA8B,UAAU;AAC7C,qBAAmB,KAAK,MAAM,QAAQ;AACtC,OAAK,KAAK;AACZ;AACA,aAAa,UAAU,CAAC,UAAU;AAClC,EAAS,cAAc,kBAAkB;AAgDzC,aAAa,UAAU,UAAU,SAAU,SAAS,UAAU,IAAI;AAChE,MAAI,OAAO;AACX,MAAI,OAAO,YAAY,UAAU;AAC/B,cAAU,CAAC,OAAO;AAAA,EACpB;AACA,UAAQ,QAAQ,SAAU,QAAQ;AAChC,SAAK,WAAW,QAAQ,UAAU,SAAU,SAASA,SAAQ,OAAO;AAClE,aAAO,GAAG,OAAO;AAAA,IACnB,GAAG,IAAI;AAAA,EACT,CAAC;AACH;AAKA,aAAa,UAAU,OAAO,WAAY;AAAC;",
  "names": ["action"]
}
