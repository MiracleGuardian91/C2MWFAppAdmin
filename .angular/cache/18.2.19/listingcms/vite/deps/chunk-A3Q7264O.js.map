{
  "version": 3,
  "sources": ["../../../../../../node_modules/diagram-js/lib/util/Elements.js"],
  "sourcesContent": ["import { assign, filter, find, isArray, isNumber, isObject, isUndefined, groupBy, forEach } from 'min-dash';\n\n/**\n * @typedef {import('../model/Types').Connection} Connection\n * @typedef {import('../model/Types').Element} Element\n * @typedef {import('../model/Types').Shape} Shape\n *\n * @typedef {import('../util/Types').Rect} Rect\n *\n * @typedef { {\n *   allShapes: Record<string, Shape>,\n *   allConnections: Record<string, Connection>,\n *   topLevel: Record<string, Element>,\n *   enclosedConnections: Record<string, Connection>,\n *   enclosedElements: Record<string, Element>\n * } } Closure\n */\n\n/**\n * Get parent elements.\n *\n * @param {Element[]} elements\n *\n * @return {Element[]}\n */\nexport function getParents(elements) {\n  // find elements that are not children of any other elements\n  return filter(elements, function (element) {\n    return !find(elements, function (e) {\n      return e !== element && getParent(element, e);\n    });\n  });\n}\nfunction getParent(element, parent) {\n  if (!parent) {\n    return;\n  }\n  if (element === parent) {\n    return parent;\n  }\n  if (!element.parent) {\n    return;\n  }\n  return getParent(element.parent, parent);\n}\n\n/**\n * Adds an element to a collection and returns true if the\n * element was added.\n *\n * @param {Object[]} elements\n * @param {Object} element\n * @param {boolean} [unique]\n */\nexport function add(elements, element, unique) {\n  var canAdd = !unique || elements.indexOf(element) === -1;\n  if (canAdd) {\n    elements.push(element);\n  }\n  return canAdd;\n}\n\n/**\n * Iterate over each element in a collection, calling the iterator function `fn`\n * with (element, index, recursionDepth).\n *\n * Recurse into all elements that are returned by `fn`.\n *\n * @param {Element|Element[]} elements\n * @param {(element: Element, index: number, depth: number) => Element[] | boolean | undefined} fn\n * @param {number} [depth] maximum recursion depth\n */\nexport function eachElement(elements, fn, depth) {\n  depth = depth || 0;\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n  forEach(elements, function (s, i) {\n    var filter = fn(s, i, depth);\n    if (isArray(filter) && filter.length) {\n      eachElement(filter, fn, depth + 1);\n    }\n  });\n}\n\n/**\n * Collects self + child elements up to a given depth from a list of elements.\n *\n * @param {Element|Element[]} elements the elements to select the children from\n * @param {boolean} unique whether to return a unique result set (no duplicates)\n * @param {number} maxDepth the depth to search through or -1 for infinite\n *\n * @return {Element[]} found elements\n */\nexport function selfAndChildren(elements, unique, maxDepth) {\n  var result = [],\n    processedChildren = [];\n  eachElement(elements, function (element, i, depth) {\n    add(result, element, unique);\n    var children = element.children;\n\n    // max traversal depth not reached yet\n    if (maxDepth === -1 || depth < maxDepth) {\n      // children exist && children not yet processed\n      if (children && add(processedChildren, children, unique)) {\n        return children;\n      }\n    }\n  });\n  return result;\n}\n\n/**\n * Return self + direct children for a number of elements\n *\n * @param {Element[]} elements to query\n * @param {boolean} [allowDuplicates] to allow duplicates in the result set\n *\n * @return {Element[]} the collected elements\n */\nexport function selfAndDirectChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, 1);\n}\n\n/**\n * Return self + ALL children for a number of elements\n *\n * @param {Element[]} elements to query\n * @param {boolean} [allowDuplicates] to allow duplicates in the result set\n *\n * @return {Element[]} the collected elements\n */\nexport function selfAndAllChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, -1);\n}\n\n/**\n * Gets the the closure for all selected elements,\n * their enclosed children and connections.\n *\n * @param {Element[]} elements\n * @param {boolean} [isTopLevel=true]\n * @param {Closure} [closure]\n *\n * @return {Closure} newClosure\n */\nexport function getClosure(elements, isTopLevel, closure) {\n  if (isUndefined(isTopLevel)) {\n    isTopLevel = true;\n  }\n  if (isObject(isTopLevel)) {\n    closure = isTopLevel;\n    isTopLevel = true;\n  }\n  closure = closure || {};\n  var allShapes = copyObject(closure.allShapes),\n    allConnections = copyObject(closure.allConnections),\n    enclosedElements = copyObject(closure.enclosedElements),\n    enclosedConnections = copyObject(closure.enclosedConnections);\n  var topLevel = copyObject(closure.topLevel, isTopLevel && groupBy(elements, function (e) {\n    return e.id;\n  }));\n  function handleConnection(c) {\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\n      topLevel[c.id] = [c];\n    }\n\n    // not enclosed as a child, but maybe logically\n    // (connecting two moved elements?)\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\n    }\n    allConnections[c.id] = c;\n  }\n  function handleElement(element) {\n    enclosedElements[element.id] = element;\n    if (element.waypoints) {\n      // remember connection\n      enclosedConnections[element.id] = allConnections[element.id] = element;\n    } else {\n      // remember shape\n      allShapes[element.id] = element;\n\n      // remember all connections\n      forEach(element.incoming, handleConnection);\n      forEach(element.outgoing, handleConnection);\n\n      // recurse into children\n      return element.children;\n    }\n  }\n  eachElement(elements, handleElement);\n  return {\n    allShapes: allShapes,\n    allConnections: allConnections,\n    topLevel: topLevel,\n    enclosedConnections: enclosedConnections,\n    enclosedElements: enclosedElements\n  };\n}\n\n/**\n * Returns the surrounding bbox for all elements in\n * the array or the element primitive.\n *\n * @param {Element|Element[]} elements\n * @param {boolean} [stopRecursion=false]\n *\n * @return {Rect}\n */\nexport function getBBox(elements, stopRecursion) {\n  stopRecursion = !!stopRecursion;\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n  var minX, minY, maxX, maxY;\n  forEach(elements, function (element) {\n    // If element is a connection the bbox must be computed first\n    var bbox = element;\n    if (element.waypoints && !stopRecursion) {\n      bbox = getBBox(element.waypoints, true);\n    }\n    var x = bbox.x,\n      y = bbox.y,\n      height = bbox.height || 0,\n      width = bbox.width || 0;\n    if (x < minX || minX === undefined) {\n      minX = x;\n    }\n    if (y < minY || minY === undefined) {\n      minY = y;\n    }\n    if (x + width > maxX || maxX === undefined) {\n      maxX = x + width;\n    }\n    if (y + height > maxY || maxY === undefined) {\n      maxY = y + height;\n    }\n  });\n  return {\n    x: minX,\n    y: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n}\n\n/**\n * Returns all elements that are enclosed from the bounding box.\n *\n *   * If bbox.(width|height) is not specified the method returns\n *     all elements with element.x/y > bbox.x/y\n *   * If only bbox.x or bbox.y is specified, method return all elements with\n *     e.x > bbox.x or e.y > bbox.y\n *\n * @param {Element[]} elements List of Elements to search through\n * @param {Rect} bbox the enclosing bbox.\n *\n * @return {Element[]} enclosed elements\n */\nexport function getEnclosedElements(elements, bbox) {\n  var filteredElements = {};\n  forEach(elements, function (element) {\n    var e = element;\n    if (e.waypoints) {\n      e = getBBox(e);\n    }\n    if (!isNumber(bbox.y) && e.x > bbox.x) {\n      filteredElements[element.id] = element;\n    }\n    if (!isNumber(bbox.x) && e.y > bbox.y) {\n      filteredElements[element.id] = element;\n    }\n    if (e.x > bbox.x && e.y > bbox.y) {\n      if (isNumber(bbox.width) && isNumber(bbox.height) && e.width + e.x < bbox.width + bbox.x && e.height + e.y < bbox.height + bbox.y) {\n        filteredElements[element.id] = element;\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\n        filteredElements[element.id] = element;\n      }\n    }\n  });\n  return filteredElements;\n}\n\n/**\n * Get the element's type\n *\n * @param {Element} element\n *\n * @return {'connection' | 'shape' | 'root'}\n */\nexport function getType(element) {\n  if ('waypoints' in element) {\n    return 'connection';\n  }\n  if ('x' in element) {\n    return 'shape';\n  }\n  return 'root';\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nexport function isFrameElement(element) {\n  return !!(element && element.isFrame);\n}\n\n// helpers ///////////////////////////////\n\nfunction copyObject(src1, src2) {\n  return assign({}, src1 || {}, src2 || {});\n}"],
  "mappings": "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",
  "names": ["filter"]
}
