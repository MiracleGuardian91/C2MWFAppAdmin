{"version":3,"sources":["node_modules/@softarc/native-federation-runtime/fesm2022/softarc-native-federation-runtime.mjs","src/main.ts"],"sourcesContent":["function mergeImportMaps(map1, map2) {\n  return {\n    imports: {\n      ...map1.imports,\n      ...map2.imports\n    },\n    scopes: {\n      ...map1.scopes,\n      ...map2.scopes\n    }\n  };\n}\nconst nfNamespace = '__NATIVE_FEDERATION__';\nconst global = globalThis;\nglobal[nfNamespace] ??= {\n  externals: new Map(),\n  remoteNamesToRemote: new Map(),\n  baseUrlToRemoteNames: new Map()\n};\nconst globalCache = global[nfNamespace];\nconst externals = globalCache.externals;\nfunction getExternalKey(shared) {\n  return `${shared.packageName}@${shared.version}`;\n}\nfunction getExternalUrl(shared) {\n  const packageKey = getExternalKey(shared);\n  return externals.get(packageKey);\n}\nfunction setExternalUrl(shared, url) {\n  const packageKey = getExternalKey(shared);\n  externals.set(packageKey, url);\n}\nfunction getDirectory(url) {\n  const parts = url.split('/');\n  parts.pop();\n  return parts.join('/');\n}\nfunction joinPaths(path1, path2) {\n  while (path1.endsWith('/')) {\n    path1 = path1.substring(0, path1.length - 1);\n  }\n  if (path2.startsWith('./')) {\n    path2 = path2.substring(2, path2.length);\n  }\n  return `${path1}/${path2}`;\n}\nconst remoteNamesToRemote = globalCache.remoteNamesToRemote;\nconst baseUrlToRemoteNames = globalCache.baseUrlToRemoteNames;\nfunction addRemote(remoteName, remote) {\n  remoteNamesToRemote.set(remoteName, remote);\n  baseUrlToRemoteNames.set(remote.baseUrl, remoteName);\n}\nfunction getRemoteNameByBaseUrl(baseUrl) {\n  return baseUrlToRemoteNames.get(baseUrl);\n}\nfunction isRemoteInitialized(baseUrl) {\n  return baseUrlToRemoteNames.has(baseUrl);\n}\nfunction getRemote(remoteName) {\n  return remoteNamesToRemote.get(remoteName);\n}\nfunction hasRemote(remoteName) {\n  return remoteNamesToRemote.has(remoteName);\n}\nfunction appendImportMap(importMap) {\n  document.head.appendChild(Object.assign(document.createElement('script'), {\n    type: 'importmap-shim',\n    innerHTML: JSON.stringify(importMap)\n  }));\n}\n\n/**\n * Initialize the federation runtime\n * @param remotesOrManifestUrl\n * @param options The cacheTag allows you to invalidate the cache of the remoteEntry.json files, pass a new value with every release (f.ex. the version number)\n */\nasync function initFederation(remotesOrManifestUrl = {}, options) {\n  const cacheOption = options?.cacheTag ? `?t=${options.cacheTag}` : '';\n  const remotes = typeof remotesOrManifestUrl === 'string' ? await loadManifest(remotesOrManifestUrl + cacheOption) : remotesOrManifestUrl;\n  const url = './remoteEntry.json' + cacheOption;\n  const hostInfo = await loadFederationInfo(url);\n  const hostImportMap = await processHostInfo(hostInfo);\n  const remotesImportMap = await processRemoteInfos(remotes, {\n    throwIfRemoteNotFound: false,\n    ...options\n  });\n  const importMap = mergeImportMaps(hostImportMap, remotesImportMap);\n  appendImportMap(importMap);\n  return importMap;\n}\nasync function loadManifest(remotes) {\n  return await fetch(remotes).then(r => r.json());\n}\nasync function processRemoteInfos(remotes, options = {\n  throwIfRemoteNotFound: false\n}) {\n  const processRemoteInfoPromises = Object.keys(remotes).map(async remoteName => {\n    try {\n      let url = remotes[remoteName];\n      if (options.cacheTag) {\n        const addAppend = remotes[remoteName].includes('?') ? '&' : '?';\n        url += `${addAppend}t=${options.cacheTag}`;\n      }\n      return await processRemoteInfo(url, remoteName);\n    } catch (e) {\n      const error = `Error loading remote entry for ${remoteName} from file ${remotes[remoteName]}`;\n      if (options.throwIfRemoteNotFound) {\n        throw new Error(error);\n      }\n      console.error(error);\n      return null;\n    }\n  });\n  const remoteImportMaps = await Promise.all(processRemoteInfoPromises);\n  const importMap = remoteImportMaps.reduce((acc, remoteImportMap) => remoteImportMap ? mergeImportMaps(acc, remoteImportMap) : acc, {\n    imports: {},\n    scopes: {}\n  });\n  return importMap;\n}\nasync function processRemoteInfo(federationInfoUrl, remoteName) {\n  const baseUrl = getDirectory(federationInfoUrl);\n  const remoteInfo = await loadFederationInfo(federationInfoUrl);\n  if (!remoteName) {\n    remoteName = remoteInfo.name;\n  }\n  const importMap = createRemoteImportMap(remoteInfo, remoteName, baseUrl);\n  addRemote(remoteName, {\n    ...remoteInfo,\n    baseUrl\n  });\n  return importMap;\n}\nfunction createRemoteImportMap(remoteInfo, remoteName, baseUrl) {\n  const imports = processExposed(remoteInfo, remoteName, baseUrl);\n  const scopes = processRemoteImports(remoteInfo, baseUrl);\n  return {\n    imports,\n    scopes\n  };\n}\nasync function loadFederationInfo(url) {\n  const info = await fetch(url).then(r => r.json());\n  return info;\n}\nfunction processRemoteImports(remoteInfo, baseUrl) {\n  const scopes = {};\n  const scopedImports = {};\n  for (const shared of remoteInfo.shared) {\n    const outFileName = getExternalUrl(shared) ?? joinPaths(baseUrl, shared.outFileName);\n    setExternalUrl(shared, outFileName);\n    scopedImports[shared.packageName] = outFileName;\n  }\n  scopes[baseUrl + '/'] = scopedImports;\n  return scopes;\n}\nfunction processExposed(remoteInfo, remoteName, baseUrl) {\n  const imports = {};\n  for (const exposed of remoteInfo.exposes) {\n    const key = joinPaths(remoteName, exposed.key);\n    const value = joinPaths(baseUrl, exposed.outFileName);\n    imports[key] = value;\n  }\n  return imports;\n}\nasync function processHostInfo(hostInfo, relBundlesPath = './') {\n  const imports = hostInfo.shared.reduce((acc, cur) => ({\n    ...acc,\n    [cur.packageName]: relBundlesPath + cur.outFileName\n  }), {});\n  for (const shared of hostInfo.shared) {\n    setExternalUrl(shared, relBundlesPath + shared.outFileName);\n  }\n  return {\n    imports,\n    scopes: {}\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nasync function loadRemoteModule(optionsOrRemoteName, exposedModule) {\n  const options = normalizeOptions(optionsOrRemoteName, exposedModule);\n  await ensureRemoteInitialized(options);\n  const remoteName = getRemoteNameByOptions(options);\n  const remote = getRemote(remoteName);\n  const fallback = options.fallback;\n  const remoteError = !remote ? 'unknown remote ' + remoteName : '';\n  if (!remote && !fallback) {\n    throw new Error(remoteError);\n  } else if (!remote) {\n    logClientError(remoteError);\n    return Promise.resolve(fallback);\n  }\n  const exposed = remote.exposes.find(e => e.key === options.exposedModule);\n  const exposedError = !exposed ? `Unknown exposed module ${options.exposedModule} in remote ${remoteName}` : '';\n  if (!exposed && !fallback) {\n    throw new Error(exposedError);\n  } else if (!exposed) {\n    logClientError(exposedError);\n    return Promise.resolve(fallback);\n  }\n  const url = joinPaths(remote.baseUrl, exposed.outFileName);\n  try {\n    const module = _import(url);\n    return module;\n  } catch (e) {\n    if (fallback) {\n      console.error('error loading remote module', e);\n      return fallback;\n    }\n    throw e;\n  }\n}\nfunction _import(url) {\n  return typeof importShim !== 'undefined' ? importShim(url) : import(/* @vite-ignore */url);\n}\nfunction getRemoteNameByOptions(options) {\n  let remoteName;\n  if (options.remoteName) {\n    remoteName = options.remoteName;\n  } else if (options.remoteEntry) {\n    const baseUrl = getDirectory(options.remoteEntry);\n    remoteName = getRemoteNameByBaseUrl(baseUrl);\n  } else {\n    throw new Error('unexpcted arguments: Please pass remoteName or remoteEntry');\n  }\n  if (!remoteName) {\n    throw new Error('unknown remoteName ' + remoteName);\n  }\n  return remoteName;\n}\nasync function ensureRemoteInitialized(options) {\n  if (options.remoteEntry && !isRemoteInitialized(getDirectory(options.remoteEntry))) {\n    const importMap = await processRemoteInfo(options.remoteEntry);\n    appendImportMap(importMap);\n  }\n}\nfunction normalizeOptions(optionsOrRemoteName, exposedModule) {\n  let options;\n  if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n    options = {\n      remoteName: optionsOrRemoteName,\n      exposedModule\n    };\n  } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n    options = optionsOrRemoteName;\n  } else {\n    throw new Error('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n  }\n  return options;\n}\nfunction logClientError(error) {\n  if (typeof window !== 'undefined') {\n    console.error(error);\n  }\n}\nconst defaultShareOptions = {\n  singleton: false,\n  requiredVersionPrefix: ''\n};\nfunction getShared(options = defaultShareOptions) {\n  const nfc = window;\n  const externals = nfc.__NATIVE_FEDERATION__.externals;\n  const shared = {};\n  const allKeys = [...externals.keys()];\n  const keys = allKeys.filter(k => !k.startsWith('/@id/') && !k.startsWith('@angular-architects/module-federation') && !k.endsWith('@')).sort();\n  for (const key of keys) {\n    const idx = key.lastIndexOf('@');\n    const pkgName = key.substring(0, idx);\n    const version = key.substring(idx + 1);\n    const path = externals.get(key) ?? '';\n    const shareObj = {\n      version,\n      get: async () => {\n        const lib = await window.importShim(path);\n        return () => lib;\n      },\n      shareConfig: {\n        singleton: options.singleton,\n        requiredVersion: options.requiredVersionPrefix + version\n      }\n    };\n    if (!shared[pkgName]) {\n      shared[pkgName] = [];\n    }\n    shared[pkgName].push(shareObj);\n  }\n  return shared;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { getShared, initFederation, loadRemoteModule, mergeImportMaps, processHostInfo, processRemoteInfo, processRemoteInfos };\n","import { initFederation } from '@angular-architects/native-federation';\r\n\r\ninitFederation()\r\n  .catch(err => console.error(err))\r\n  .then(_ => import('./bootstrap'))\r\n  .catch(err => console.error(err));\r\n"],"mappings":"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","names":[],"x_google_ignoreList":[0]}